# DesignPatternsExamples
[![GitHub watchers](https://img.shields.io/github/watchers/badges/shields.svg?style=social&label=Watch)]()
[![Github Releases](https://img.shields.io/github/downloads/atom/atom/latest/total.svg)]()
[![GitHub issue last update](https://img.shields.io/github/issues/detail/last-update/badges/shields/979.svg)]()
[![GitHub last commit](https://img.shields.io/github/last-commit/google/skia.svg)]()
[![GitHub tag](https://img.shields.io/github/tag/expressjs/express.svg)]()
[![Github file size](https://img.shields.io/github/size/webcaetano/craft/build/phaser-craft.min.js.svg)]()

### Testes criado para estudos de Design Patterns

  Este projeto consiste em criar uma solution para exemplificar alguns PADRÕES DE PROJETOS seguindo as premissas do livro [Padrões de Projeto - Soluções Reutilizáveis de Software Orientado a Objetos](https://www.amazon.com.br/Padr%C3%B5es-Projetos-Solu%C3%A7%C3%B5es-Reutiliz%C3%A1veis-Orientados-ebook/dp/B016N8RJUQ)
 
 Vou tentar me basear no nível de usabilidade informado no [dofactory](http://www.dofactory.com/net/design-patterns) .
 
 Abaixo segue uma lista com todos os padro citados no [dofactory](http://www.dofactory.com/net/design-patterns) e conforme eu for concluindo o exemplo colocarei o link direto para a página com os códigos, fazendo assim que a lista servira como um índice para a navegação entre os exemplos.
 
 Para cada exemplo, criarei um breve resumo com uma pequena explicação.

 ## Uma breve introdução
Segundo Gamma (2000), projetar um software orientado a objeto nunca foi uma tarefa fácil, mas a busca por reutilização de código vem sendo cada vez maior, para tornar as aplicações finais mais poderosas com o menor esforço possível do programador em curto espaço de tempo. Porem essa tarefa de reutilização de código é algo muito complexo e difícil que normalmente é executado com eficiência por projetistas experientes.  
  
Devido a esse novo enfoque surgiu à ideia de um catálogo com Padrões de Projetos (Design Patterns em inglês), os quais são uma espécie de manual de boas práticas a serem seguidas na estruturação de projeto de software, que ajudam a escolher as alternativas de projeto que tornam um sistema reutilizável e a evitar as alternativas que possam comprometer essa reutilização. 
  
Os padrões de design são soluções para problemas de design de software que você encontra continuamente em seu dia a dia no desenvolvimento de aplicativos. Os padrões são sobre projetos reutilizáveis e interações de objetos.
  
Mais importante do que entender como é a implementação de um padrão de projeto, é entender a motivação do padrão: em quais casos ele faz sentido e deve ser aplicado.


## Padrões criativos

  * Abstract Factory -- Cria uma instância de várias famílias de aulas
  * Builder -- Separa a construção do objeto da sua representação
  * Factory Method -- Cria uma instância de várias classes derivadas
  * Prototype --	Uma instância totalmente inicializada a ser copiada ou clonada
  * Singleton --	Uma classe da qual apenas uma única instância pode existir  
  
## Padrões Estruturais

  * Adapter --	Corresponder interfaces de diferentes classes
  * Bridge --	Separa a interface de um objeto de sua implementação
  * Composite --	Uma estrutura em árvore de objetos simples e compostos
  * Decorator --	Adicione responsabilidades dinamicamente aos objetos
  * Facade -- Uma única classe que representa um subsistema inteiro
  * Flyweight --	Uma instância de grão fino usada para compartilhamento eficiente
  * Proxy --	Um objeto que representa outro objeto

## Padrões comportamentais

  * [Chain of Responsibility](ChainOfResponsibility) -- Uma maneira de passar um pedido entre uma cadeia de objetos
  * Command -- Encapsular uma solicitação de comando como um objeto
  * Interpreter -- Uma maneira de incluir elementos de idioma em um programa
  * Iterator -- Seqüencialmente acessar os elementos de uma coleção
  * Mediator -- Define comunicação simplificada entre classes
  * Memento --	Capture e restaure o estado interno de um objeto
  * Observer --	Uma maneira de notificar a mudança para várias aulas=
  * State --	Alterar o comportamento de um objeto quando seu estado muda
  * [Strategy](StrategyExemples) --	Encapsula um algoritmo dentro de uma classe
  * Template Method --	Adiar as etapas exatas de um algoritmo para uma subclasse
  * Visitor --	Define uma nova operação para uma classe sem alteração
